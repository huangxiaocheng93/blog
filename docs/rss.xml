<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Vincent的博客</title><link>https://blog.npex.top</link><description>Vincent的碎片知识集散地，边复习边整理，希望下次能一看就懂。偶尔也记录下其他的收获。</description><copyright>Vincent的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/33109308?s=400&amp;u=6656e9b7a16bf82f6900c8647fd74fe50b6eecc7&amp;v=4</url><title>avatar</title><link>https://blog.npex.top</link></image><lastBuildDate>Fri, 04 Jul 2025 16:19:21 +0000</lastBuildDate><managingEditor>Vincent的博客</managingEditor><ttl>60</ttl><webMaster>Vincent的博客</webMaster><item><title>关于kafka的一些问题</title><link>https://blog.npex.top/post/29.html</link><description># Kafka Broker是什么？

kafka集群中的每个节点都是一个Broker。</description><guid isPermaLink="true">https://blog.npex.top/post/29.html</guid><pubDate>Thu, 27 Mar 2025 09:36:58 +0000</pubDate></item><item><title>CAP定理</title><link>https://blog.npex.top/post/28.html</link><description># CAP定理

CAP定理是现代**分布式系统**的理论基石。</description><guid isPermaLink="true">https://blog.npex.top/post/28.html</guid><pubDate>Thu, 27 Mar 2025 09:33:57 +0000</pubDate></item><item><title>ThreadLocal和内存泄漏</title><link>https://blog.npex.top/post/26.html</link><description># 背景

`ThreadLocal` 是什么，什么场景会出现内存泄露，为什么会导致内存泄漏，我们能应该怎么用。</description><guid isPermaLink="true">https://blog.npex.top/post/26.html</guid><pubDate>Sun, 17 Nov 2024 09:47:23 +0000</pubDate></item><item><title>Intelli IDEA几个配置</title><link>https://blog.npex.top/post/25.html</link><description>记录几个自己习惯的idea配置，方便下次重新设置的时候直接对照&#13;
# 快捷键配置&#13;
&#13;
## 前进和后退&#13;
&#13;
**前进**英文关键字是`forward`，中文关键字是`前进`&#13;
&#13;
![image](https://github.com/user-attachments/assets/b803c4f0-5e9b-47a5-87f9-be817ecd5835)&#13;
&#13;
**后退**英文关键字是`back`，中文关键字是`后退`&#13;
&#13;
![image](https://github.com/user-attachments/assets/fe449256-0565-44d1-b5ce-4e0add1dbc94)&#13;
&#13;
## 删除整行&#13;
&#13;
删除整行习惯了`ctrl + D`&#13;
&#13;
![image](https://github.com/user-attachments/assets/7cdb295f-3612-4f1b-9b38-9f56d73a7b52)&#13;
&#13;
&#13;
&#13;
# 实时模板&#13;
&#13;
## 类注释模板&#13;
&#13;
这里一般会配置两个关键字，一个是`/c`，一个是`、c`，主要是兼容中文输入法时的问题。</description><guid isPermaLink="true">https://blog.npex.top/post/25.html</guid><pubDate>Thu, 31 Oct 2024 01:53:30 +0000</pubDate></item><item><title>MySQL几种字符集的区别</title><link>https://blog.npex.top/post/24.html</link><description># 字符集&#13;
MySQL使用较多的字符集就是**utf8**和**utf8mb4**，了解一下这两者的区别。</description><guid isPermaLink="true">https://blog.npex.top/post/24.html</guid><pubDate>Thu, 24 Oct 2024 08:41:06 +0000</pubDate></item><item><title>TCP/IP协议系列之ARP协议</title><link>https://blog.npex.top/post/23.html</link><description># ARP协议是什么&#13;
&#13;
在网络层，唯一地址是IP地址，所以在网络层，只能知道下一个节点的IP地址。</description><guid isPermaLink="true">https://blog.npex.top/post/23.html</guid><pubDate>Sat, 12 Oct 2024 11:38:40 +0000</pubDate></item><item><title>TCP/IP协议系列之ICMP协议</title><link>https://blog.npex.top/post/22.html</link><description># TCP/IP协议系列&#13;
&#13;
[TCP/IP协议系列之网络层](https://blog.npex.top/post/21.html)&#13;
&#13;
# ICMP是什么&#13;
ICMP全称是**互联网控制报文协议**（Internet Control Message Protocol）ICMP协议工作在网络层，是IP的辅助协议，也是控制协议。</description><guid isPermaLink="true">https://blog.npex.top/post/22.html</guid><pubDate>Wed, 09 Oct 2024 01:51:36 +0000</pubDate></item><item><title>TCP/IP协议系列之网络层</title><link>https://blog.npex.top/post/21.html</link><description># TCP/IP协议系列

[TCP/IP协议系列之网络基础](https://huangxiaocheng93.github.io/blog/post/19.html)

[TCP/IP协议系列之物理层和数据链路层](https://huangxiaocheng93.github.io/blog/post/20.html)

在TCP/IP网络模型中，虽然说划分了五层，但是对物理层和数据链路层，TCP/IP并并没有做什么规范和限制，TCP/IP以这两层的功能是透明的为前提。</description><guid isPermaLink="true">https://blog.npex.top/post/21.html</guid><pubDate>Tue, 01 Oct 2024 10:16:12 +0000</pubDate></item><item><title>TCP/IP协议系列之物理层和数据链路层</title><link>https://blog.npex.top/post/20.html</link><description># 透明的物理层和数据链路层
我们知道TCP/IP协议簇把网络划分为五层，第一层是物理层，第二层是数据链路层，但是**实际上TCP/IP协议簇中并没有定义任何物理层和数据链路层的协议，也就是说所有物理层和数据链路层的协议都不属于TCP/IP协议簇**。</description><guid isPermaLink="true">https://blog.npex.top/post/20.html</guid><pubDate>Fri, 27 Sep 2024 07:41:53 +0000</pubDate></item><item><title>TCP/IP协议系列之网络基础</title><link>https://blog.npex.top/post/19.html</link><description># 网络是什么？

网络应该是现代社会离不开的东西了，每个人都依赖网络做很多事情，例如打电话、发微信、购物等等。</description><guid isPermaLink="true">https://blog.npex.top/post/19.html</guid><pubDate>Thu, 26 Sep 2024 04:24:41 +0000</pubDate></item><item><title>Java的类加载机制</title><link>https://blog.npex.top/post/18.html</link><description># 什么是类加载？&#13;
&#13;
我们编写的代码，通过编译器的编译，变成class文件，也就是字节码。</description><guid isPermaLink="true">https://blog.npex.top/post/18.html</guid><pubDate>Wed, 25 Sep 2024 02:06:33 +0000</pubDate></item><item><title>Redis的过期key清理策略</title><link>https://blog.npex.top/post/17.html</link><description># 从一个线上问题说起&#13;
&#13;
某天收到一个error日志告警，告警的代码如下（隐去了一些信息和无关的代码）：&#13;
&#13;
```java&#13;
public List query() {&#13;
&#13;
        ......&#13;
        &#13;
        // 缓存key&#13;
        String cacheKey = 'test';&#13;
        &#13;
        // 判断缓存是否存在，如果不存在就重新加载缓存&#13;
        if (!Boolean.TRUE.equals(stringRedisTemplate.hasKey(cacheKey))) {&#13;
            return reload(businessId, pageIndex, defaultPageSize);&#13;
        }&#13;
&#13;
        // 获取缓存数据，缓存是hash结构&#13;
        BoundHashOperations&lt;String, String, Object&gt; operations = stringRedisTemplate.boundHashOps(cacheKey);&#13;
        log.info('查询列表, 缓存详情, values:{}', JsonUtil.toJson(operations.entries()));&#13;
        &#13;
        &#13;
        ListCache listCache = JsonUtil.fromStr(&#13;
                Optional.ofNullable(operations.get(pageIndex.toString())).map(Object::toString).orElse(null),&#13;
                ListCache.class);&#13;
&#13;
        // 获取total和ttl，total和ttl是hash的两个key&#13;
        Integer total = Optional.ofNullable(operations.get(CacheConstants.KEY_HASH_TOTAL))&#13;
                .map(obj -&gt; Integer.valueOf(obj.toString())).orElse(null);&#13;
        Long ttl = Optional.ofNullable(operations.get(CacheConstants.LIST_KEY_HASH_TTL))&#13;
                .map(obj -&gt; Long.valueOf(obj.toString())).orElse(null);&#13;
        log.info('查询列表, total:{}, ttl:{}, listCache:{}', total, ttl, JsonUtil.toJson(listCache));&#13;
&#13;
        // 非预期情况，走重新加载缓存的逻辑&#13;
        if (total == null || ttl == null) {&#13;
            // 就是这条日志导致的告警&#13;
            log.error('查询列表, 从缓存获取到的total或ttl值为空, cacheKey:{}, total:{}, ttl:{}', cacheKey, total, ttl);&#13;
            return reload(businessId, pageIndex, defaultPageSize);&#13;
        }&#13;
        ......&#13;
    }&#13;
```&#13;
&#13;
代码的大致意思是在读取一个缓存，缓存是hash结构，所有的hash key都是同时加载进去的，如果缓存不存在，那么走reload方法重新加载缓存并返回，如果缓存存在会直接返回。</description><guid isPermaLink="true">https://blog.npex.top/post/17.html</guid><pubDate>Fri, 20 Sep 2024 00:17:50 +0000</pubDate></item><item><title>Redis的内存淘汰策略</title><link>https://blog.npex.top/post/16.html</link><description>Redis的内存淘汰策略分为两个方向，**不进行数据淘汰**和**进行数据淘汰**。</description><guid isPermaLink="true">https://blog.npex.top/post/16.html</guid><pubDate>Thu, 19 Sep 2024 04:10:52 +0000</pubDate></item><item><title>git-helper.sh</title><link>https://blog.npex.top/post/15.html</link><description>日常工作中经常要合并分支，例如推送变更到开发或者测试分支。</description><guid isPermaLink="true">https://blog.npex.top/post/15.html</guid><pubDate>Thu, 19 Sep 2024 03:58:06 +0000</pubDate></item><item><title>Java HttpMediaTypeNotAcceptableException异常排查</title><link>https://blog.npex.top/post/14.html</link><description># 背景&#13;
&#13;
今天收到一个线上告警，是一个没见过的报错：&#13;
&#13;
`org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation`&#13;
&#13;
这个错误翻译过来叫：`无法找到可接受的代理`&#13;
&#13;
请求返回码是：`406`&#13;
&#13;
# 分析&#13;
&#13;
我们代码里面没有定义`406`这个返回码，所以可以推测这个错误码是spring或其他自检返回的。</description><guid isPermaLink="true">https://blog.npex.top/post/14.html</guid><pubDate>Thu, 19 Sep 2024 03:48:14 +0000</pubDate></item><item><title>CentOS 8无法安装snapd问题</title><link>https://blog.npex.top/post/13.html</link><description>使用certbot安装证书时需要通过snapd来安装，centos8下安装snapd报错：&#13;
&#13;
```bash&#13;
上次元数据过期检查：0:07:16 前，执行于 2023年07月03日 星期一 03时03分49秒。</description><guid isPermaLink="true">https://blog.npex.top/post/13.html</guid><pubDate>Thu, 19 Sep 2024 03:39:48 +0000</pubDate></item><item><title>Werner Vogels：俭约架构师的七大黄金法则！</title><link>https://blog.npex.top/post/12.html</link><description># **法则一**&#13;
&#13;
**将成本视为一种非功能性需求。</description><guid isPermaLink="true">https://blog.npex.top/post/12.html</guid><pubDate>Thu, 19 Sep 2024 03:37:36 +0000</pubDate></item><item><title>MySQL执行计划详解</title><link>https://blog.npex.top/post/11.html</link><description>| Column | Meaning |
|--------|---------|
| id | The SELECT identifier |
| select_type | The SELECT type |
| table | The table for the output row |
| partitions | The matching partitions |
| type | The join type |
| possible_keys | The possible indexes to choose |
| key | The index actually chosen |
| key_len | The length of the chosen key |
| ref | The columns compared to the index |
| rows | Estimate of rows to be examined |
| filtered | Percentage of rows filtered by table condition |
| extra | Additional information |

# SQL语句优化的目标

SQL优化的指标很多，优化手段也是很多， 往往我们迷思在这些指标和优化手段里的时候，就是遗忘了SQL优化最本质的目标。</description><guid isPermaLink="true">https://blog.npex.top/post/11.html</guid><pubDate>Wed, 18 Sep 2024 03:32:32 +0000</pubDate></item><item><title>Java volatile关键字</title><link>https://blog.npex.top/post/10.html</link><description># 准备&#13;
&#13;
在了解volatile关键字之前，必须先了解 [Java内存模型](https://huangxiaocheng93.github.io/blog/post/Java-nei-cun-mo-xing.html) 有关的知识，所以后续会默认在Java内存模型的基础上说明。</description><guid isPermaLink="true">https://blog.npex.top/post/10.html</guid><pubDate>Wed, 18 Sep 2024 03:25:36 +0000</pubDate></item><item><title>Java内存模型</title><link>https://blog.npex.top/post/9.html</link><description># Java的内存模型是干啥的？&#13;
&#13;
很多人都知道有一个**Java内存模型**（因为面试会问），还有很多人会和**JVM内存模型**搞混（因为不理解这两者的区别），实际上这两者并不是在同一个层次堆内存的划分，两者之间没有任何关系。</description><guid isPermaLink="true">https://blog.npex.top/post/9.html</guid><pubDate>Wed, 18 Sep 2024 03:05:26 +0000</pubDate></item><item><title>CentOS安装Nginx</title><link>https://blog.npex.top/post/8.html</link><description># 命令整合&#13;
&#13;
## 安装&#13;
&#13;
```bash&#13;
yum -y install epel-release&#13;
yum -y update&#13;
yum -y install nginx&#13;
systemctl enable nginx&#13;
systemctl start nginx&#13;
&#13;
```&#13;
&#13;
# yum命令&#13;
&#13;
yum相当于是centos版的软件管家，里面已经收录了很多软件，方便对软件进行管理。</description><guid isPermaLink="true">https://blog.npex.top/post/8.html</guid><pubDate>Tue, 17 Sep 2024 08:09:57 +0000</pubDate></item><item><title>Redis持久化和主从同步</title><link>https://blog.npex.top/post/7.html</link><description>Redis的持久化为什么要放在和主从同步一起写呢？因为这两者就是一件事。</description><guid isPermaLink="true">https://blog.npex.top/post/7.html</guid><pubDate>Tue, 17 Sep 2024 08:06:21 +0000</pubDate></item><item><title>TCP协议详解</title><link>https://blog.npex.top/post/6.html</link><description># TCP是什么？&#13;
&#13;
TCP是TCP/IP协议簇中的**传输层**协议，TCP是面向**有连接的**，**高可靠性**的传输层协议。</description><guid isPermaLink="true">https://blog.npex.top/post/6.html</guid><pubDate>Mon, 16 Sep 2024 04:59:00 +0000</pubDate></item><item><title>CentOS防火墙管理</title><link>https://blog.npex.top/post/5.html</link><description># 命令整合&#13;
&#13;
## 安装&#13;
&#13;
```bash&#13;
yum -y install firewalld&#13;
systemctl start firewalld&#13;
systemctl enable firewalld&#13;
&#13;
```&#13;
&#13;
## 开放80和443端口&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --add-port=80/tcp --permanent&#13;
firewall-cmd --zone=public --add-port=80/udp --permanent&#13;
firewall-cmd --zone=public --add-port=443/tcp --permanent&#13;
firewall-cmd --zone=public --add-port=443/udp --permanent&#13;
firewall-cmd --reload&#13;
&#13;
```&#13;
&#13;
# 安装firewalld&#13;
&#13;
```bash&#13;
yum -y install firewalld&#13;
```&#13;
&#13;
# 常用命令&#13;
&#13;
## 启动&#13;
&#13;
```bash&#13;
systemctl start firewalld&#13;
```&#13;
&#13;
## 关闭&#13;
&#13;
```bash&#13;
systemctl stop firewalld&#13;
```&#13;
&#13;
## 查看状态&#13;
&#13;
```bash&#13;
systemctl status firewalld&#13;
```&#13;
&#13;
## 开机启动&#13;
&#13;
```&#13;
systemctl enable firewalld&#13;
```&#13;
&#13;
## 开机禁用&#13;
&#13;
```&#13;
systemctl disable firewalld&#13;
```&#13;
&#13;
## 安装并配置开启启动&#13;
&#13;
```bash&#13;
yum -y install firewalld&#13;
systemctl start firewalld&#13;
systemctl enable firewalld&#13;
&#13;
```&#13;
&#13;
# 配置firewalld-cmd&#13;
&#13;
查看版本&#13;
&#13;
```bash&#13;
firewall-cmd --version&#13;
```&#13;
&#13;
查看帮助&#13;
&#13;
```bash&#13;
firewall-cmd --help&#13;
```&#13;
&#13;
显示状态&#13;
&#13;
```bash&#13;
firewall-cmd --state&#13;
```&#13;
&#13;
查看所有打开的端口&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --list-ports&#13;
```&#13;
&#13;
更新防火墙规则&#13;
&#13;
```bash&#13;
firewall-cmd --reload&#13;
```&#13;
&#13;
查看区域信息&#13;
&#13;
```bash&#13;
firewall-cmd --get-active-zones&#13;
```&#13;
&#13;
查看指定接口所属区域&#13;
&#13;
```bash&#13;
firewall-cmd --get-zone-of-interface=eth0&#13;
```&#13;
&#13;
拒绝所有包&#13;
&#13;
```bash&#13;
firewall-cmd --panic-on&#13;
```&#13;
&#13;
取消拒绝状态&#13;
&#13;
```bash&#13;
firewall-cmd --panic-off&#13;
```&#13;
&#13;
查看是否拒绝&#13;
&#13;
```bash&#13;
firewall-cmd --query-panic&#13;
```&#13;
&#13;
## 开启一个端口&#13;
&#13;
### 添加&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --add-port=80/tcp --permanent&#13;
```&#13;
&#13;
（--permanent永久生效，没有此参数重启后失效）&#13;
&#13;
### 重新载入&#13;
&#13;
开启或者关闭了端口后需要reload才能生效&#13;
&#13;
```bash&#13;
firewall-cmd --reload&#13;
```&#13;
&#13;
### 查看&#13;
&#13;
yes即为开启&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --query-port=80/tcp&#13;
```&#13;
&#13;
### 删除&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --remove-port=80/tcp --permanent&#13;
```&#13;
&#13;
### 备注&#13;
&#13;
systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</description><guid isPermaLink="true">https://blog.npex.top/post/5.html</guid><pubDate>Mon, 16 Sep 2024 02:44:28 +0000</pubDate></item><item><title>Java GC中的可达性分析算法</title><link>https://blog.npex.top/post/4.html</link><description>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。</description><guid isPermaLink="true">https://blog.npex.top/post/4.html</guid><pubDate>Sun, 15 Sep 2024 10:19:44 +0000</pubDate></item><item><title>通过certbot安装免费的tls证书</title><link>https://blog.npex.top/post/3.html</link><description># certbot官网地址&#13;
[Certbot](https://certbot.eff.org)&#13;
&#13;
# 安装snapd&#13;
&#13;
snapd是一个包管理工具（类似应用商店），certbot的工具是发布在这里。</description><guid isPermaLink="true">https://blog.npex.top/post/3.html</guid><pubDate>Sun, 15 Sep 2024 10:04:28 +0000</pubDate></item><item><title>Java线程池ThreadPoolExecutor详解</title><link>https://blog.npex.top/post/2.html</link><description># **什么是线程池**&#13;
&#13;
线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。</description><guid isPermaLink="true">https://blog.npex.top/post/2.html</guid><pubDate>Sat, 14 Sep 2024 07:09:55 +0000</pubDate></item><item><title>解决CentOS 8无法通过yum下载软件的问题</title><link>https://blog.npex.top/post/1.html</link><description>原因是CentOS 8已于2021年12月31日停止维护，在2022年1月31日，CentOS团队终于从官方镜像中移除CentOS 8的所有包。</description><guid isPermaLink="true">https://blog.npex.top/post/1.html</guid><pubDate>Sat, 14 Sep 2024 04:12:54 +0000</pubDate></item></channel></rss>