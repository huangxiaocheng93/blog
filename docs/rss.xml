<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Vincent的技术博客</title><link>https://huangxiaocheng93.github.io/blog</link><description>记录知识碎片</description><copyright>Vincent的技术博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/33109308?s=400&amp;u=6656e9b7a16bf82f6900c8647fd74fe50b6eecc7&amp;v=4</url><title>avatar</title><link>https://huangxiaocheng93.github.io/blog</link></image><lastBuildDate>Tue, 01 Oct 2024 10:18:38 +0000</lastBuildDate><managingEditor>Vincent的技术博客</managingEditor><ttl>60</ttl><webMaster>Vincent的技术博客</webMaster><item><title>TCP/IP协议系列之物理层和数据链路层</title><link>https://huangxiaocheng93.github.io/blog/post/20.html</link><description>我们已经知道了TCP/IP协议簇把网络划分成了五层，但是实际上TCP/IP协议并没有定义物理层和数据链路层，TCP/IP把这两层的实现当作透明的。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/20.html</guid><pubDate>Fri, 27 Sep 2024 07:41:53 +0000</pubDate></item><item><title>TCP/IP协议系列之网络基础</title><link>https://huangxiaocheng93.github.io/blog/post/19.html</link><description># 网络是什么？&#13;
&#13;
网络应该是现代社会离不开的东西了，每个人都依赖网络做很多事情，例如打电话、发微信、购物等等。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/19.html</guid><pubDate>Thu, 26 Sep 2024 04:24:41 +0000</pubDate></item><item><title>Java的类加载机制</title><link>https://huangxiaocheng93.github.io/blog/post/18.html</link><description># 什么是类加载？&#13;
&#13;
我们编写的代码，通过编译器的编译，变成class文件，也就是字节码。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/18.html</guid><pubDate>Wed, 25 Sep 2024 02:06:33 +0000</pubDate></item><item><title>Redis的过期key清理策略</title><link>https://huangxiaocheng93.github.io/blog/post/17.html</link><description># 从一个线上问题说起&#13;
&#13;
某天收到一个error日志告警，告警的代码如下（隐去了一些信息和无关的代码）：&#13;
&#13;
```java&#13;
public List query() {&#13;
&#13;
        ......&#13;
        &#13;
        // 缓存key&#13;
        String cacheKey = 'test';&#13;
        &#13;
        // 判断缓存是否存在，如果不存在就重新加载缓存&#13;
        if (!Boolean.TRUE.equals(stringRedisTemplate.hasKey(cacheKey))) {&#13;
            return reload(businessId, pageIndex, defaultPageSize);&#13;
        }&#13;
&#13;
        // 获取缓存数据，缓存是hash结构&#13;
        BoundHashOperations&lt;String, String, Object&gt; operations = stringRedisTemplate.boundHashOps(cacheKey);&#13;
        log.info('查询列表, 缓存详情, values:{}', JsonUtil.toJson(operations.entries()));&#13;
        &#13;
        &#13;
        ListCache listCache = JsonUtil.fromStr(&#13;
                Optional.ofNullable(operations.get(pageIndex.toString())).map(Object::toString).orElse(null),&#13;
                ListCache.class);&#13;
&#13;
        // 获取total和ttl，total和ttl是hash的两个key&#13;
        Integer total = Optional.ofNullable(operations.get(CacheConstants.KEY_HASH_TOTAL))&#13;
                .map(obj -&gt; Integer.valueOf(obj.toString())).orElse(null);&#13;
        Long ttl = Optional.ofNullable(operations.get(CacheConstants.LIST_KEY_HASH_TTL))&#13;
                .map(obj -&gt; Long.valueOf(obj.toString())).orElse(null);&#13;
        log.info('查询列表, total:{}, ttl:{}, listCache:{}', total, ttl, JsonUtil.toJson(listCache));&#13;
&#13;
        // 非预期情况，走重新加载缓存的逻辑&#13;
        if (total == null || ttl == null) {&#13;
            // 就是这条日志导致的告警&#13;
            log.error('查询列表, 从缓存获取到的total或ttl值为空, cacheKey:{}, total:{}, ttl:{}', cacheKey, total, ttl);&#13;
            return reload(businessId, pageIndex, defaultPageSize);&#13;
        }&#13;
        ......&#13;
    }&#13;
```&#13;
&#13;
代码的大致意思是在读取一个缓存，缓存是hash结构，所有的hash key都是同时加载进去的，如果缓存不存在，那么走reload方法重新加载缓存并返回，如果缓存存在会直接返回。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/17.html</guid><pubDate>Fri, 20 Sep 2024 00:17:50 +0000</pubDate></item><item><title>Redis的内存淘汰策略</title><link>https://huangxiaocheng93.github.io/blog/post/16.html</link><description>Redis的内存淘汰策略分为两个方向，**不进行数据淘汰**和**进行数据淘汰**。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/16.html</guid><pubDate>Thu, 19 Sep 2024 04:10:52 +0000</pubDate></item><item><title>git-helper.sh</title><link>https://huangxiaocheng93.github.io/blog/post/15.html</link><description>日常工作中经常要合并分支，例如推送变更到开发或者测试分支。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/15.html</guid><pubDate>Thu, 19 Sep 2024 03:58:06 +0000</pubDate></item><item><title>Java HttpMediaTypeNotAcceptableException异常排查</title><link>https://huangxiaocheng93.github.io/blog/post/14.html</link><description># 背景&#13;
&#13;
今天收到一个线上告警，是一个没见过的报错：&#13;
&#13;
`org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation`&#13;
&#13;
这个错误翻译过来叫：`无法找到可接受的代理`&#13;
&#13;
请求返回码是：`406`&#13;
&#13;
# 分析&#13;
&#13;
我们代码里面没有定义`406`这个返回码，所以可以推测这个错误码是spring或其他自检返回的。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/14.html</guid><pubDate>Thu, 19 Sep 2024 03:48:14 +0000</pubDate></item><item><title>CentOS 8无法安装snapd问题</title><link>https://huangxiaocheng93.github.io/blog/post/13.html</link><description>使用certbot安装证书时需要通过snapd来安装，centos8下安装snapd报错：&#13;
&#13;
```bash&#13;
上次元数据过期检查：0:07:16 前，执行于 2023年07月03日 星期一 03时03分49秒。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/13.html</guid><pubDate>Thu, 19 Sep 2024 03:39:48 +0000</pubDate></item><item><title>Werner Vogels：俭约架构师的七大黄金法则！</title><link>https://huangxiaocheng93.github.io/blog/post/12.html</link><description># **法则一**&#13;
&#13;
**将成本视为一种非功能性需求。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/12.html</guid><pubDate>Thu, 19 Sep 2024 03:37:36 +0000</pubDate></item><item><title>MySQL执行计划详解</title><link>https://huangxiaocheng93.github.io/blog/post/11.html</link><description>| Column | Meaning |&#13;
|--------|---------|&#13;
| id | The SELECT identifier |&#13;
| select_type | The SELECT type |&#13;
| table | The table for the output row |&#13;
| partitions | The matching partitions |&#13;
| type | The join type |&#13;
| possible_keys | The possible indexes to choose |&#13;
| key | The index actually chosen |&#13;
| key_len | The length of the chosen key |&#13;
| ref | The columns compared to the index |&#13;
| rows | Estimate of rows to be examined |&#13;
| filtered | Percentage of rows filtered by table condition |&#13;
| extra | Additional information |&#13;
&#13;
&#13;
## id&#13;
&#13;
意为select查询的序列号，包含一组数字，表示查询中执行select字句或操作表的顺序&#13;
&#13;
- id相同，顺序自然自上而下&#13;
- id全不同，如果是子查询，id的序号会递增，id数字越大越先执行&#13;
- id部分相同，先按数字大的先执行，数字相同的按自上而下顺序执行&#13;
&#13;
## select_type&#13;
&#13;
查询类型，用于区别普通查询、联合查询、子查询等复杂查询&#13;
&#13;
- **simple**&#13;
    &#13;
    简单的select查询，查询中不包含子查询或union&#13;
    &#13;
- **primary**&#13;
    &#13;
    查询中包含子查询，最外层查询则标记为primary&#13;
    &#13;
- **subquery**&#13;
    &#13;
    在select或where中包含子查询&#13;
    &#13;
- **derived**&#13;
    &#13;
    在from列表中包含的子查询，也叫派生类，MySQL会递归执行这些子查询，把结果放在临时表里&#13;
    &#13;
- **union**&#13;
    &#13;
    若第二个select出现在union之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED&#13;
    &#13;
&#13;
## table&#13;
&#13;
显示这一行的数据是关于哪张表，内容为表名或者别名，可能是临时表或者union合并结果集&#13;
&#13;
## type&#13;
&#13;
显示访问类型，表示以何种方式访问了数据，从最好到最差的排列为：&#13;
&#13;
**system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all**&#13;
&#13;
**一般情况下，得保证查询至少达到range，最好能达到ref**&#13;
&#13;
- **system** &#13;
表里只有一行记录，是const的特例，一般不会出现&#13;
- **const**&#13;
表里至多有一个匹配行&#13;
- **eq_ref** &#13;
主键索引（primary key）或者非空唯一索引（unique not null）等值扫描&#13;
- **ref** &#13;
非主键非唯一索引等值扫描&#13;
- **range** &#13;
利用索引查询的时候限定了范围，一般出现于between &lt;（&lt;=） &gt; (&gt;=) in 等查询&#13;
- **index** &#13;
全索引扫描，比all效率高，index从索引中扫描，而all是从硬盘上扫描&#13;
- **all** &#13;
全表扫描，一般出现此类型的sql并且数据量较大的话就要进行优化&#13;
&#13;
## **possible_keys**&#13;
&#13;
显示的是可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引会被列出，但不一定被查询实际使用&#13;
&#13;
## **key**&#13;
&#13;
实际使用的索引，如果为null，则没有用到索引&#13;
若查询中用到了索引覆盖，则该索引和查询的select字段重叠，仅出现在key列表中&#13;
&#13;
## **key_len**&#13;
&#13;
表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好&#13;
&#13;
## **ref**&#13;
&#13;
显示索引的哪一列被使用了，如果可能的话，是一个常数&#13;
&#13;
## **rows**&#13;
&#13;
 根据表的统计信息及索引选用情况，大致估算出找到所需记录需要读取的行数&#13;
&#13;
## **extra**&#13;
&#13;
包含的额外信息，无法在一个字段中概述但是依旧重要的额外信息&#13;
&#13;
- **using filesort** &#13;
文件排序意为MySQL无法利用索引进行排序，而使用了外部的排序算法，常见于order by 或 group by&#13;
- **using temporary** &#13;
使用了临时表保存中间结果，查询完成后临时表删除&#13;
- **using index** &#13;
索引覆盖意为直接从索引中读取数据，而不用访问数据表，如果同时出现 using where 表明索引被用来执行索引键值的查找，否则，索引被用来读取数据而不是执行查找操作&#13;
- **using where** &#13;
使用where进行条件过滤&#13;
- **using join buffer** &#13;
使用了连接缓存&#13;
- **impossible where**  &#13;
where语句结果是false&#13;
- **select tables optimized away** &#13;
在没有group by字句情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT（*）操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化&#13;
- **distinct** &#13;
优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/11.html</guid><pubDate>Wed, 18 Sep 2024 03:32:32 +0000</pubDate></item><item><title>Java volatile关键字</title><link>https://huangxiaocheng93.github.io/blog/post/10.html</link><description># 准备&#13;
&#13;
在了解volatile关键字之前，必须先了解 [Java内存模型](https://huangxiaocheng93.github.io/blog/post/Java-nei-cun-mo-xing.html) 有关的知识，所以后续会默认在Java内存模型的基础上说明。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/10.html</guid><pubDate>Wed, 18 Sep 2024 03:25:36 +0000</pubDate></item><item><title>Java内存模型</title><link>https://huangxiaocheng93.github.io/blog/post/9.html</link><description># Java的内存模型是干啥的？&#13;
&#13;
很多人都知道有一个**Java内存模型**（因为面试会问），还有很多人会和**JVM内存模型**搞混（因为不理解这两者的区别），实际上这两者并不是在同一个层次堆内存的划分，两者之间没有任何关系。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/9.html</guid><pubDate>Wed, 18 Sep 2024 03:05:26 +0000</pubDate></item><item><title>CentOS安装Nginx</title><link>https://huangxiaocheng93.github.io/blog/post/8.html</link><description># 命令整合&#13;
&#13;
## 安装&#13;
&#13;
```bash&#13;
yum -y install epel-release&#13;
yum -y update&#13;
yum -y install nginx&#13;
systemctl enable nginx&#13;
systemctl start nginx&#13;
&#13;
```&#13;
&#13;
# yum命令&#13;
&#13;
yum相当于是centos版的软件管家，里面已经收录了很多软件，方便对软件进行管理。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/8.html</guid><pubDate>Tue, 17 Sep 2024 08:09:57 +0000</pubDate></item><item><title>Redis持久化和主从同步</title><link>https://huangxiaocheng93.github.io/blog/post/7.html</link><description>Redis的持久化为什么要放在和主从同步一起写呢？因为这两者就是一件事。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/7.html</guid><pubDate>Tue, 17 Sep 2024 08:06:21 +0000</pubDate></item><item><title>TCP协议详解</title><link>https://huangxiaocheng93.github.io/blog/post/6.html</link><description># TCP是什么？&#13;
&#13;
TCP是TCP/IP协议簇中的**传输层**协议，TCP是面向**有连接的**，**高可靠性**的传输层协议。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/6.html</guid><pubDate>Mon, 16 Sep 2024 04:59:00 +0000</pubDate></item><item><title>CentOS防火墙管理</title><link>https://huangxiaocheng93.github.io/blog/post/5.html</link><description># 命令整合&#13;
&#13;
## 安装&#13;
&#13;
```bash&#13;
yum -y install firewalld&#13;
systemctl start firewalld&#13;
systemctl enable firewalld&#13;
&#13;
```&#13;
&#13;
## 开放80和443端口&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --add-port=80/tcp --permanent&#13;
firewall-cmd --zone=public --add-port=80/udp --permanent&#13;
firewall-cmd --zone=public --add-port=443/tcp --permanent&#13;
firewall-cmd --zone=public --add-port=443/udp --permanent&#13;
firewall-cmd --reload&#13;
&#13;
```&#13;
&#13;
# 安装firewalld&#13;
&#13;
```bash&#13;
yum -y install firewalld&#13;
```&#13;
&#13;
# 常用命令&#13;
&#13;
## 启动&#13;
&#13;
```bash&#13;
systemctl start firewalld&#13;
```&#13;
&#13;
## 关闭&#13;
&#13;
```bash&#13;
systemctl stop firewalld&#13;
```&#13;
&#13;
## 查看状态&#13;
&#13;
```bash&#13;
systemctl status firewalld&#13;
```&#13;
&#13;
## 开机启动&#13;
&#13;
```&#13;
systemctl enable firewalld&#13;
```&#13;
&#13;
## 开机禁用&#13;
&#13;
```&#13;
systemctl disable firewalld&#13;
```&#13;
&#13;
## 安装并配置开启启动&#13;
&#13;
```bash&#13;
yum -y install firewalld&#13;
systemctl start firewalld&#13;
systemctl enable firewalld&#13;
&#13;
```&#13;
&#13;
# 配置firewalld-cmd&#13;
&#13;
查看版本&#13;
&#13;
```bash&#13;
firewall-cmd --version&#13;
```&#13;
&#13;
查看帮助&#13;
&#13;
```bash&#13;
firewall-cmd --help&#13;
```&#13;
&#13;
显示状态&#13;
&#13;
```bash&#13;
firewall-cmd --state&#13;
```&#13;
&#13;
查看所有打开的端口&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --list-ports&#13;
```&#13;
&#13;
更新防火墙规则&#13;
&#13;
```bash&#13;
firewall-cmd --reload&#13;
```&#13;
&#13;
查看区域信息&#13;
&#13;
```bash&#13;
firewall-cmd --get-active-zones&#13;
```&#13;
&#13;
查看指定接口所属区域&#13;
&#13;
```bash&#13;
firewall-cmd --get-zone-of-interface=eth0&#13;
```&#13;
&#13;
拒绝所有包&#13;
&#13;
```bash&#13;
firewall-cmd --panic-on&#13;
```&#13;
&#13;
取消拒绝状态&#13;
&#13;
```bash&#13;
firewall-cmd --panic-off&#13;
```&#13;
&#13;
查看是否拒绝&#13;
&#13;
```bash&#13;
firewall-cmd --query-panic&#13;
```&#13;
&#13;
## 开启一个端口&#13;
&#13;
### 添加&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --add-port=80/tcp --permanent&#13;
```&#13;
&#13;
（--permanent永久生效，没有此参数重启后失效）&#13;
&#13;
### 重新载入&#13;
&#13;
开启或者关闭了端口后需要reload才能生效&#13;
&#13;
```bash&#13;
firewall-cmd --reload&#13;
```&#13;
&#13;
### 查看&#13;
&#13;
yes即为开启&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --query-port=80/tcp&#13;
```&#13;
&#13;
### 删除&#13;
&#13;
```bash&#13;
firewall-cmd --zone=public --remove-port=80/tcp --permanent&#13;
```&#13;
&#13;
### 备注&#13;
&#13;
systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/5.html</guid><pubDate>Mon, 16 Sep 2024 02:44:28 +0000</pubDate></item><item><title>Java GC中的可达性分析算法</title><link>https://huangxiaocheng93.github.io/blog/post/4.html</link><description>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/4.html</guid><pubDate>Sun, 15 Sep 2024 10:19:44 +0000</pubDate></item><item><title>通过certbot安装免费的tls证书</title><link>https://huangxiaocheng93.github.io/blog/post/3.html</link><description># certbot官网地址&#13;
[Certbot](https://certbot.eff.org)&#13;
&#13;
# 安装snapd&#13;
&#13;
snapd是一个包管理工具（类似应用商店），certbot的工具是发布在这里。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/3.html</guid><pubDate>Sun, 15 Sep 2024 10:04:28 +0000</pubDate></item><item><title>Java线程池ThreadPoolExecutor详解</title><link>https://huangxiaocheng93.github.io/blog/post/2.html</link><description># **什么是线程池**&#13;
&#13;
线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/2.html</guid><pubDate>Sat, 14 Sep 2024 07:09:55 +0000</pubDate></item><item><title>解决CentOS 8无法通过yum下载软件的问题</title><link>https://huangxiaocheng93.github.io/blog/post/1.html</link><description>原因是CentOS 8已于2021年12月31日停止维护，在2022年1月31日，CentOS团队终于从官方镜像中移除CentOS 8的所有包。</description><guid isPermaLink="true">https://huangxiaocheng93.github.io/blog/post/1.html</guid><pubDate>Sat, 14 Sep 2024 04:12:54 +0000</pubDate></item></channel></rss>