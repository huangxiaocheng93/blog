# Java的内存模型是干啥的？

很多人都知道有一个**Java内存模型**（因为面试会问），还有很多人会和**JVM内存模型**搞混（因为不理解这两者的区别），实际上这两者并不是在同一个层次堆内存的划分，两者之间没有任何关系。

先澄清一下这两者的区别：
<html><table frame=void style="margin-left: auto; margin-right: auto;"><tr><td>
JVM内存模型描述的是程序运行过程中，字节码（类）和运行时数据（类对象等）以及对象的引用所保存的位置，例如：堆是保存对象示例的位置，线程运行中用到的对象引用，局部变量等保存在栈上，字节码数据保存在方法区。
</td><td>

![Image00014](https://github.com/user-attachments/assets/d71e8342-d679-43c8-b013-580a61f6f66c)

</td></tr></table></html>
<html><table frame=void style="margin-left: auto; margin-right: auto;"><tr><td>
Java内存模型描述的是多线程运行的过程中，线程的工作内存是如何和主内存交互的，定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
</td><td>

![Image00220](https://github.com/user-attachments/assets/22398f57-1533-498f-a8cc-0dd92b2b1b1e)

</td></tr></table></html>

为什么要有个Java内存模型呢？Java内存模型主要是为了协调多线程运行的情况下，不同线程应该怎么读取和写入内存中的变量。例如不能的线程在读取和修改同一个变量，要怎么解决读到脏数据或者覆盖其他线程的修改的情况。

# 硬件的效率与一致性

Java的内存模型实际上和物理计算机的模型有些相似，现代处理器都是多核处理器，多个处理器核心在同时工作时，很有可能会用到同一块内存区域的数据，同时CPU并不是直接与主内存交互，在CPU和主内存之间还有好几层高速缓存，用来缓冲主内存和CPU之间的速度差异。
![Image00219](https://github.com/user-attachments/assets/a622ed43-c6ca-428c-acfb-da71c8b7b021)

为了解决这一问题，CPU在读写缓存和把缓存同步会主内存时都会遵守一定的规范，避免并发带来的问题，这个规范叫做**缓存一致性协议**。

缓存一致性协议有很多种，由于这次并不是主要讨论缓存一致性协议，所以不做展开。

但是我们可以发现，上面这张图和Java内存模型的图非常相似，场景也非常相识，我们可以把一个处理器核心类比为Java的一条线程，处理器核心的高速缓存类比为线程的工作内存，那么Java定义的Save和Load等操作规范就可以类比为CPU的缓存一致性协议，实际上功能实现的目的也是一致的。

# Java内存模型

Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。值得注意的时此处的变量（Variables）不包括直接分配在栈上的局部变量等，因为栈上分配的变量是线程私有的，不会被共享，自然就不会存在多线程竞争问题。

![Image00220](https://github.com/user-attachments/assets/122cd456-dcf0-4afa-9a6a-e3c172514e7a)

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

## **内存间交互操作**

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，但这是另外一件事）

### 操作的定义

- **lock**（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- **unlock**（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read**（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- **load**（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- **use**（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- **assign**（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store**（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- **write**（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

这个协议的定义，我们可以类比为CPU的内存一致性协议。

### 操作的规则

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。
- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

实际上根据上述的描述，我们可以看出来：

读取操作：read → load → use

写入操作：assign → store → write

所以8种操作也可以简化为4种来理解，但是仅仅只是描述的变化，实际实现上仍然是8种。